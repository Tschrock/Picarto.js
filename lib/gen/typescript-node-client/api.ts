// tslint:disable
/**
 * Picarto.TV API Documentation
 * The Picarto.TV API documentation  Note, for fixed access tokens, the header that needs to be sent is of the format: `Authorization: Bearer yourTokenHere`  This can be generated at https://oauth.picarto.tv/ 
 *
 * OpenAPI spec version: 1.1.1
 * Contact: support@picarto.tv
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');
//import Promise = require('bluebird');

let defaultBasePath = 'https://api.picarto.tv/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

/**
* Basic info about a channel
*/
export class BasicChannelInfo {
    /**
    * The channel's user ID
    */
    'userId': number;
    /**
    * The name of the channel
    */
    'name': string;
}

/**
* A list of categories
*/
export class Categories extends Array<Category> {
}

/**
* Details of a category
*/
export class Category {
    /**
    * The category name
    */
    'name': string;
    /**
    * The total number of channels that are this category
    */
    'totalChannels': number;
    /**
    * The number of channels that are live using this category
    */
    'onlineChannels': number;
    /**
    * The total number of viewers
    */
    'viewers': number;
}

/**
* Details about a channel
*/
export class ChannelDetails {
    /**
    * The channel's user ID
    */
    'userId': number;
    /**
    * The name of the channel
    */
    'name': string;
    /**
    * If the channel is online
    */
    'online': boolean;
    /**
    * The number of current viewers watching this stream (0 if offline)
    */
    'viewers': number;
    /**
    * The total number of viewers this channel has had since the beginning of time
    */
    'viewersTotal': number;
    /**
    * The total number of people following this streamer
    */
    'followers': number;
    /**
    * If this channel is an adult channel
    */
    'adult': boolean;
    /**
    * The name of the category this stream is in
    */
    'category': string;
    /**
    * The account type of the channel
    */
    'accountType': ChannelDetails.AccountTypeEnum;
    /**
    * If this channel is accepting commissions
    */
    'commissions': boolean;
    /**
    * This channel's title
    */
    'title': string;
    /**
    * This channel's description panels
    */
    'descriptionPanels': Array<DescriptionPanel>;
    /**
    * If this channel is in private mode
    */
    'private': boolean;
    /**
    * If this channel is in game mode
    */
    'gaming': boolean;
    /**
    * If guest (unregistered) users can talk in chat
    */
    'guestChat': boolean;
    /**
    * The date/time this user was last live
    */
    'lastLive': Date;
    /**
    * A list of tags
    */
    'tags': Array<string>;
    /**
    * A list of channels we are multistreaming with
    */
    'multistream': Array<MultiParticipant>;
}

export namespace ChannelDetails {
    export enum AccountTypeEnum {
        Free = <any> 'free',
        Basic = <any> 'basic',
        Premium = <any> 'premium'
    }
}
/**
* A channel's description panel
*/
export class DescriptionPanel {
    /**
    * The description panel's title
    */
    'title': string;
    /**
    * The description panel's body
    */
    'body': string;
    /**
    * The description panel's attached image URL, if it exists
    */
    'image': string;
    /**
    * The attached image's link, if the image is set.
    */
    'imageLink': string;
    /**
    * The order at which this is sorted (just for convenience, can just use array index)
    */
    'position': number;
}

/**
* Information about an event
*/
export class Event {
    /**
    * Event ID
    */
    'id': string;
    'channelDetails': BasicChannelInfo;
    /**
    * The category of this event
    */
    'category': string;
    /**
    * The price (in US cents - 100 = $1.00)
    */
    'ticketPrice': number;
    /**
    * The total number of tickets able to be sold (0 = unlimited)
    */
    'ticketLimit': number;
    /**
    * The total number of tickets sold so far
    */
    'ticketsSold': number;
    /**
    * If the event has started
    */
    'started': boolean;
    /**
    * If the event is an adult event
    */
    'adult': boolean;
}

/**
* A list of events
*/
export class Events extends Array<Event> {
}

/**
* A channel we are multistreaming with
*/
export class MultiParticipant {
    /**
    * The user ID of the channel
    */
    'userId': string;
    /**
    * The channel name
    */
    'name': string;
    /**
    * If the channel is live or not
    */
    'online': boolean;
}

/**
* A list of online channels
*/
export class OnlineChannels extends Array<OnlineDetails> {
}

/**
* Details of online channels
*/
export class OnlineDetails {
    /**
    * The channel's user ID
    */
    'userId': number;
    /**
    * The name of the channel
    */
    'name': string;
    /**
    * The number of current viewers watching this stream
    */
    'viewers': number;
    /**
    * The category this stream is in
    */
    'category': string;
    /**
    * If this channel is marked as adult
    */
    'adult': boolean;
    /**
    * If this channel is gaming
    */
    'gaming': boolean;
    /**
    * If this channel is hosting or participating in a multistream
    */
    'multistream': boolean;
}

/**
* Private information about an account
*/
export class UserData {
    'channelDetails': ChannelDetails;
    /**
    * The email address of the user
    */
    'email': string;
    /**
    * The date of the channel's creation
    */
    'creationDate': Date;
    /**
    * The user's key to watch their private stream
    */
    'privateKey': string;
    /**
    * The list of users this person is following
    */
    'following': Array<BasicChannelInfo>;
    /**
    * The list of users this person is subscribed to
    */
    'subscriptions': Array<BasicChannelInfo>;
}

/**
* A registered webhook
*/
export class Webhook {
    /**
    * Webhook ID
    */
    'id': string;
    'channel': BasicChannelInfo;
    /**
    * Webhook type
    */
    'type': string;
    /**
    * Webhook target URI
    */
    'uri': string;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum BotApiApiKeys {
}

export class BotApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2Access': new OAuth(),
        'OAuth2Implicit': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: BotApiApiKeys, value: string) {
        this.authentications[BotApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2Access.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2Implicit.accessToken = token;
    }
    /**
     * 
     * Generate a bot JWT token to connect to a channel
     * @param channelId Channel ID you wish to connect to
     * @param bot Whether or not this is a bot token (&#x60;false&#x60; is a user token)
     */
    public userJwtkeyGet (channelId: number, bot: boolean) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/user/jwtkey';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling userJwtkeyGet.');
        }

        // verify required parameter 'bot' is not null or undefined
        if (bot === null || bot === undefined) {
            throw new Error('Required parameter bot was null or undefined when calling userJwtkeyGet.');
        }

        if (channelId !== undefined) {
            queryParameters['channel_id'] = channelId;
        }

        if (bot !== undefined) {
            queryParameters['bot'] = bot;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2Implicit.applyToRequest(requestOptions);

        this.authentications.OAuth2Access.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ChannelApiApiKeys {
}

export class ChannelApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2Access': new OAuth(),
        'OAuth2Implicit': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ChannelApiApiKeys, value: string) {
        this.authentications[ChannelApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2Access.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2Implicit.accessToken = token;
    }
    /**
     * 
     * Gets information about a channel by ID
     * @param channelId Channel ID of user you wish to read
     */
    public channelIdChannelIdGet (channelId: number) : Promise<{ response: http.ClientResponse; body: ChannelDetails;  }> {
        const localVarPath = this.basePath + '/channel/id/{channel_id}'
            .replace('{' + 'channel_id' + '}', String(channelId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling channelIdChannelIdGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChannelDetails;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Gets information about a channel by name
     * @param channelName Channel name of user you wish to read
     */
    public channelNameChannelNameGet (channelName: string) : Promise<{ response: http.ClientResponse; body: ChannelDetails;  }> {
        const localVarPath = this.basePath + '/channel/name/{channel_name}'
            .replace('{' + 'channel_name' + '}', String(channelName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'channelName' is not null or undefined
        if (channelName === null || channelName === undefined) {
            throw new Error('Required parameter channelName was null or undefined when calling channelNameChannelNameGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChannelDetails;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PublicApiApiKeys {
}

export class PublicApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2Access': new OAuth(),
        'OAuth2Implicit': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PublicApiApiKeys, value: string) {
        this.authentications[PublicApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2Access.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2Implicit.accessToken = token;
    }
    /**
     * 
     * Get information about all categories
     */
    public categoriesGet () : Promise<{ response: http.ClientResponse; body: Categories;  }> {
        const localVarPath = this.basePath + '/categories';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Categories;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Get all events that are about to run or are running
     */
    public eventsGet () : Promise<{ response: http.ClientResponse; body: Events;  }> {
        const localVarPath = this.basePath + '/events';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Events;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Gets all currently online channels
     * @param adult Whether or not to include adult channels (defaults to &#x60;false&#x60;)
     * @param gaming Whether or not to include gaming channels (defaults to &#x60;false&#x60;)
     * @param categories What categories to limit this to (blank/not included doesn&#39;t filter) - seperate multiple categories by a &#x60;,&#x60; character
     */
    public onlineGet (adult?: boolean, gaming?: boolean, categories?: string) : Promise<{ response: http.ClientResponse; body: OnlineChannels;  }> {
        const localVarPath = this.basePath + '/online';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (adult !== undefined) {
            queryParameters['adult'] = adult;
        }

        if (gaming !== undefined) {
            queryParameters['gaming'] = gaming;
        }

        if (categories !== undefined) {
            queryParameters['categories'] = categories;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OnlineChannels;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SensitiveApiApiKeys {
}

export class SensitiveApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2Access': new OAuth(),
        'OAuth2Implicit': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: SensitiveApiApiKeys, value: string) {
        this.authentications[SensitiveApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2Access.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2Implicit.accessToken = token;
    }
    /**
     * 
     * Get private info about the currently authenticated user
     */
    public userGet () : Promise<{ response: http.ClientResponse; body: UserData;  }> {
        const localVarPath = this.basePath + '/user';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2Implicit.applyToRequest(requestOptions);

        this.authentications.OAuth2Access.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserData;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Generate a bot JWT token to connect to a channel
     * @param channelId Channel ID you wish to connect to
     * @param bot Whether or not this is a bot token (&#x60;false&#x60; is a user token)
     */
    public userJwtkeyGet (channelId: number, bot: boolean) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/user/jwtkey';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling userJwtkeyGet.');
        }

        // verify required parameter 'bot' is not null or undefined
        if (bot === null || bot === undefined) {
            throw new Error('Required parameter bot was null or undefined when calling userJwtkeyGet.');
        }

        if (channelId !== undefined) {
            queryParameters['channel_id'] = channelId;
        }

        if (bot !== undefined) {
            queryParameters['bot'] = bot;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2Implicit.applyToRequest(requestOptions);

        this.authentications.OAuth2Access.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Get the stream key of the currently authenticated user
     */
    public userStreamkeyGet () : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/user/streamkey';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2Implicit.applyToRequest(requestOptions);

        this.authentications.OAuth2Access.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserApiApiKeys {
}

export class UserApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2Access': new OAuth(),
        'OAuth2Implicit': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UserApiApiKeys, value: string) {
        this.authentications[UserApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2Access.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2Implicit.accessToken = token;
    }
    /**
     * 
     * Get private info about the currently authenticated user
     */
    public userGet () : Promise<{ response: http.ClientResponse; body: UserData;  }> {
        const localVarPath = this.basePath + '/user';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2Implicit.applyToRequest(requestOptions);

        this.authentications.OAuth2Access.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserData;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Generate a bot JWT token to connect to a channel
     * @param channelId Channel ID you wish to connect to
     * @param bot Whether or not this is a bot token (&#x60;false&#x60; is a user token)
     */
    public userJwtkeyGet (channelId: number, bot: boolean) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/user/jwtkey';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling userJwtkeyGet.');
        }

        // verify required parameter 'bot' is not null or undefined
        if (bot === null || bot === undefined) {
            throw new Error('Required parameter bot was null or undefined when calling userJwtkeyGet.');
        }

        if (channelId !== undefined) {
            queryParameters['channel_id'] = channelId;
        }

        if (bot !== undefined) {
            queryParameters['bot'] = bot;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2Implicit.applyToRequest(requestOptions);

        this.authentications.OAuth2Access.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Get the stream key of the currently authenticated user
     */
    public userStreamkeyGet () : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/user/streamkey';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2Implicit.applyToRequest(requestOptions);

        this.authentications.OAuth2Access.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhookApiApiKeys {
}

export class WebhookApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2Access': new OAuth(),
        'OAuth2Implicit': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: WebhookApiApiKeys, value: string) {
        this.authentications[WebhookApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2Access.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2Implicit.accessToken = token;
    }
    /**
     * 
     * Get all registered webhooks for your account
     * @param clientId Your application&#39;s client ID
     * @param clientSecret Your application&#39;s client secret
     * @param channelId A channel ID to filter by
     */
    public webhooksGet (clientId: string, clientSecret: string, channelId?: number) : Promise<{ response: http.ClientResponse; body: Array<Webhook>;  }> {
        const localVarPath = this.basePath + '/webhooks';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling webhooksGet.');
        }

        // verify required parameter 'clientSecret' is not null or undefined
        if (clientSecret === null || clientSecret === undefined) {
            throw new Error('Required parameter clientSecret was null or undefined when calling webhooksGet.');
        }

        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (clientSecret !== undefined) {
            queryParameters['client_secret'] = clientSecret;
        }

        if (channelId !== undefined) {
            queryParameters['channel_id'] = channelId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Webhook>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Register a webhook
     * @param type The webhook type
     * @param uri Webhook destination URI
     */
    public webhooksPost (type: string, uri: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/webhooks';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling webhooksPost.');
        }

        // verify required parameter 'uri' is not null or undefined
        if (uri === null || uri === undefined) {
            throw new Error('Required parameter uri was null or undefined when calling webhooksPost.');
        }

        let useFormData = false;

        if (type !== undefined) {
            formParams['type'] = type;
        }

        if (uri !== undefined) {
            formParams['uri'] = uri;
        }

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2Implicit.applyToRequest(requestOptions);

        this.authentications.OAuth2Access.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Delete a webhook
     * @param webhookId The webhook ID
     * @param clientId Your application&#39;s client ID
     * @param clientSecret Your application&#39;s client secret
     */
    public webhooksWebhookIdDelete (webhookId: number, clientId: string, clientSecret: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/webhooks/{webhook_id}'
            .replace('{' + 'webhook_id' + '}', String(webhookId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling webhooksWebhookIdDelete.');
        }

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling webhooksWebhookIdDelete.');
        }

        // verify required parameter 'clientSecret' is not null or undefined
        if (clientSecret === null || clientSecret === undefined) {
            throw new Error('Required parameter clientSecret was null or undefined when calling webhooksWebhookIdDelete.');
        }

        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (clientSecret !== undefined) {
            queryParameters['client_secret'] = clientSecret;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Get a webhook
     * @param webhookId The webhook ID
     * @param clientId Your application&#39;s client ID
     * @param clientSecret Your application&#39;s client secret
     */
    public webhooksWebhookIdGet (webhookId: number, clientId: string, clientSecret: string) : Promise<{ response: http.ClientResponse; body: Webhook;  }> {
        const localVarPath = this.basePath + '/webhooks/{webhook_id}'
            .replace('{' + 'webhook_id' + '}', String(webhookId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling webhooksWebhookIdGet.');
        }

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling webhooksWebhookIdGet.');
        }

        // verify required parameter 'clientSecret' is not null or undefined
        if (clientSecret === null || clientSecret === undefined) {
            throw new Error('Required parameter clientSecret was null or undefined when calling webhooksWebhookIdGet.');
        }

        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (clientSecret !== undefined) {
            queryParameters['client_secret'] = clientSecret;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Webhook;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Update a webhook&#39;s URI  Note: You can not change the webhook type. To do that you must create a new webhook, authenticated by the user. 
     * @param webhookId The webhook ID
     * @param uri Webhook destination URI
     * @param clientId Your application&#39;s client ID
     * @param clientSecret Your application&#39;s client secret
     */
    public webhooksWebhookIdPut (webhookId: number, uri: string, clientId: string, clientSecret: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/webhooks/{webhook_id}'
            .replace('{' + 'webhook_id' + '}', String(webhookId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling webhooksWebhookIdPut.');
        }

        // verify required parameter 'uri' is not null or undefined
        if (uri === null || uri === undefined) {
            throw new Error('Required parameter uri was null or undefined when calling webhooksWebhookIdPut.');
        }

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling webhooksWebhookIdPut.');
        }

        // verify required parameter 'clientSecret' is not null or undefined
        if (clientSecret === null || clientSecret === undefined) {
            throw new Error('Required parameter clientSecret was null or undefined when calling webhooksWebhookIdPut.');
        }

        let useFormData = false;

        if (uri !== undefined) {
            formParams['uri'] = uri;
        }

        if (clientId !== undefined) {
            formParams['client_id'] = clientId;
        }

        if (clientSecret !== undefined) {
            formParams['client_secret'] = clientSecret;
        }

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
